All right, so we have reached to the end of this section on storage and databases.

Let's take a moment to wrap up everything we have covered in this section, and we will see what we

have learned.

So we began with an introduction to storage in system design where we explored different type of storages

like databases, object file block storage.

This help us understand when to choose what kind of storage based on type of data access pattern and

reliability requirement.

Then we move to SQL versus NoSQL database models.

Use SQL when your data is highly structured, needs relational modeling, and strong consistency is

required.

Think about transactional systems.

On the other hand, NoSQL is great for large scale, flexible and distributed systems like social media

platforms or IoT frameworks.

Next, we dived into the advanced database topics where we discussed sharding, replication and polyglot

persistence.

These techniques are essential when you need to scale, read, write loads or use different types of

databases for different components in a system.

After that, we explored object storage, which is preferred for handling unstructured data like videos,

backups, logs, photos, especially when you need scalability and metadata tagging for the unstructured

data.

We have also discussed file systems and distributed storage such as HDFS and Cephfs, which are usually

useful when you need high throughput access to large volumes of data, which is common in analytics

and big data use cases.

Finally, we wrapped up with big data fundamentals, where we talked about the six V's of big data,

why traditional storage fails at scale, and how distributed systems like HDFS help us in dealing with

real time and batch data workloads.

Together, these concepts gives us a solid foundation for making the right storage and data architecture

decisions in any system design scenario.

So this concludes the section six of this course on Mastering System Design.

What is in the next section?

In the next section we shift our focus to performance.

We will look at how to make systems that not just work, but work fast and efficiently.

We will try to understand the concepts, tools and techniques that can help us in creating high performance

applications.

So I will see you in the next one.
